# День 7. Kubernetes и Infrastructure as Code

[kubernetes] [terraform] [iac] [cloud]

Мы научились упаковывать приложения в Docker. Но что делать, когда контейнеров становится не 5, а 500? Как обновить приложение без простоя (Zero Downtime)? Как управлять десятком серверов?
Здесь в игру вступает "тяжелая артиллерия" DevOps: Оркестрация и Инфраструктура как Код.

---

## Kubernetes (К8s): Стандарт де-факто

Docker Compose отличен для локальной разработки, но в продакшене он управляет контейнерами только на _одном_ сервере.
**Kubernetes** — это операционная система для кластера. Вы даете ему 100 серверов, и он рассматривает их как один огромный компьютер.

### Анатомия Кластера: Brain vs Muscle
Kubernetes — это сложная распределенная система, состоящая из **Control Plane** (Управляющего слоя) и **Worker Nodes** (Рабочих лошадок).

**1. Control Plane (Мозг)**:
*   **API Server**: Единственная точка входа в кластер. Все команды (от вас или от внутренних компонентов) проходят через REST API этого сервиса.
*   **etcd**: Распределенная база данных (key-value). Это "память" кластера. Здесь хранится конфигурация всех запущенных подов. Если вы потеряете данные etcd — вы потеряете кластер навсегда.
*   **Scheduler**: Планировщик. Он следит за ресурсами и решает: "Ага, на сервере Node-5 свободно 4Гб памяти, значит, новый контейнер отправится туда".
*   **Controller Manager**: Главный цикл управления. Он бесконечно сверяет *Желаемое состояние* (описанное в YAML) с *Текущим*. Если один под исчез, Контроллер заметит разницу и прикажет создать новый.

**2. Worker Node (Мышцы)**:
*   **Kubelet**: "Капитан" на корабле. Агент, который слушает приказы API Сервера и управляет Docker'ом на конкретной машине.
*   **Kube-proxy**: Сетевой компонент. Настраивает правила маршрутизации (iptables/IPVS), чтобы сервисы могли общаться друг с другом.

### Основные примитивы K8s

В отличие от Docker, в K8s "атомом" является не контейнер, а **Pod**.

1.  **Pod (Стручок)**: Группа из одного или нескольких контейнеров, имеющих общий IP и `localhost`. Они живут и умирают вместе.
2.  **Deployment**: Это контроллер. Вы говорите ему: "Хочу, чтобы всегда работало 3 копии моего Пода". Если один сервер сгорит, Deployment заметит нехватку и запустит копию на другом сервере.
3.  **Service**: Сетевая абстракция. Стабильный IP-адрес, за которым скрываются наши 3 пода. Он работает как внутренний балансировщик нагрузки.

### Практика: Ваш первый манифест

Вместо императивных команд (`docker run`), мы пишем декларативные YAML файлы.

`app-deployment.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-web-app
spec:
  replicas: 3 # Магия: хотим 3 копии
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
        - name: nginx
          image: nginx:1.14.2
          ports:
            - containerPort: 80
```

Команда `kubectl apply -f app-deployment.yaml` отправит этот чертеж в кластер, и K8s начнет действовать.

---

## Infrastructure as Code (IaC): Terraform

Раньше админы настраивали сервера руками: заходили по SSH, ставили пакеты, правили конфиги. Или кликали кнопочки в панели управления AWS.
Это называется **ClickOps**, и это зло. Человек ошибается, забывает, что сделал, и документация устаревает.

**Terraform** позволяет описать всю инфраструктуру (сервера, сети, базы данных, DNS) в виде кода.
_Принцип_: Декларативность. Вы описываете _конечное состояние_, а Terraform сам решает, что нужно создать, изменить или удалить.

### Сердце Terraform: State File
Магия Terraform кроется в файле `terraform.tfstate`.
Когда вы создаете сервер, Terraform записывает в этот JSON-файл связь: "Ресурс `aws_instance.web` соответствует реальному серверу с ID `i-0123456789` в облаке Amazon".
**Важно**:
1.  **Truth**: Для Terraform этот файл — единственная истина. Если вы удалите сервер руками через консоль AWS, Terraform не узнает об этом, пока вы не сделаете `terraform refresh`.
2.  **Sensitive Data**: В этом файле могут храниться пароли в открытом виде. Никогда не кладите `tfstate` в публичный Git-репозиторий! В командах этот файл хранят в закрытом S3-бакете (Remote State).

### Практика: Поднимаем сервер в коде

Пример конфигурации (`main.tf`) для создания сервера в облаке (на примере AWS):

```hcl
provider "aws" {
  region = "us-west-2"
}

resource "aws_instance" "web_server" {
  ami           = "ami-0c55b159cbfafe1f0" # Образ Ubuntu
  instance_type = "t2.micro"

  tags = {
    Name = "MyDevOpsServer"
  }
}
```

Команды:

1.  `terraform init` — скачивает плагины для AWS.
2.  `terraform plan` — показывает, что он _собирается_ сделать (Dry Run).
3.  `terraform apply` — реально создает сервер.

Если вы измените `instance_type` на `t2.large` и снова запустите `apply`, Terraform не создаст новый сервер, а изменит (resize) существующий.

---

## Эволюция архитектуры: Итог

Мы прошли путь от ручного управления к полной автоматизации.

1.  **Железо** (Bare Metal) -> **Виртуализация**.
2.  **Ручная настройка** (Bash) -> **Configuration Management** (Ansible).
3.  **Одиночные процессы** -> **Контейнеры** (Docker).
4.  **Ручной деплой** -> **CI/CD Pipelines**.
5.  **Ручное управление серверами** -> **Orchestration** (Kubernetes) & **IaC** (Terraform).

### Куда расти дальше (Roadmap 2.0)

Вам предстоит углубить знания в каждой из этих областей:

- **Helm**: Пакетный менеджер для K8s (как apt/brew, но для всего кластера).
- **Prometheus & Grafana**: Стандарт мониторинга для K8s.
- **Cloud Providers (AWS/GCP/Azure)**: Изучите managed-сервисы (RDS, S3, EKS).

Удачи! Путь DevOps бесконечен и это прекрасно.
