# День 1. Основы Linux и Bash

[tools] [devops] [linux]

Отношения с "черным экраном" терминала у всех складываются по-разному. Кто-то видит в нем архаизм из 80-х, а кто-то — самый мощный интерфейс взаимодействия с машиной. В мире DevOps операционная система Linux является не просто платформой, а фундаментальной средой обитания. Практически всё, что мы будем делать дальше — от Docker контейнеров до Kubernetes кластеров — базируется на примитивах ядра Linux.

В этой заметке я постарался собрать целостную картину того, как устроена эта среда, отойдя от сухого перечисления команд.

---

## Философия Unix

Чтобы понять Linux, нужно понять философию Unix, заложенную полвека назад. Она строится на нескольких принципах, которые до сих пор определяют архитектуру современных систем:

1.  **Всё есть файл**. Жесткий диск — это файл (`/dev/sda`), клавиатура — это файл, даже сетевое соединение можно представить как файловый дескриптор. Это позволяет использовать одни и те же инструменты (например, `read` и `write`) для работы с документом на диске и с потоком данных от веб-камеры.
2.  **Делайте одну вещь, и делайте её хорошо**. В отличие от Windows, где программы часто представляют собой "комбайны", в Linux принято создавать маленькие утилиты. `ls` только показывает файлы. `grep` только ищет текст. Сила системы проявляется в возможности комбинировать эти утилиты через **Пайпы** (`|`), передавая вывод одной программы на вход другой.

### Дистрибутивы: Иллюзия выбора
Новичков часто пугает "зоопарк" версий Linux. На самом деле, различия между ними минимальны и касаются в основном двух вещей: системы управления пакетами и идеологии обновлений.

- **Debian/Ubuntu** (семейство `.deb`) — баланс между новизной и стабильностью. Стандарт де-факто для разработки.
- **RHEL/CentOS/Rocky** (семейство `.rpm`) — выбор консервативного энтерпрайза. Если вам нужно, чтобы сервер работал 10 лет без изменений — вам сюда.
- **Alpine** — экстремальный минимализм. Выкинуто всё лишнее, чтобы образ занимал 5 мегабайт. Идеален для контейнеров, но неудобен для повседневной работы человека.

## Файловая система: Жизнь от Корня

В Windows мы привыкли к дискам `C:\`, `D:\`. В Linux структура монолитна. Всё начинается с корня `/` (root), и физические диски просто "монтируются" в разные папки этого дерева.
Если заглянуть внутрь:

- `/etc` — нервная система. Здесь лежат все конфигурационные файлы. Изменение файлов здесь меняет поведение системы.
- `/var` (variable) — изменяемые данные. Логи, базы данных, кэши сайтов растут именно здесь. Если место на диске кончилось — скорее всего, виноват `/var`.
- `/proc` и `/sys` — это не файлы на диске, а иллюзия. Это интерфейс ядра. Читая файлы отсюда, вы читаете данные из оперативной памяти ядра (например, информацию о процессоре).

### Глубокое погружение: Inode
Часто можно услышать фразу "файл — это просто ссылка". Это правда.
На уровне диска файл описывается структурой **Inode** (индексная нода). Она хранит метаданные: кто владелец, когда создан, где физически лежат данные. Но она **не хранит имя файла**.
Имя файла — это просто запись в телефонной книге (директории), которая говорит: "файл `report.txt` соответствует Inode номер 12345".
Это приводит нас к интересным следствиям:

1.  У файла может быть много имен (**Hard Links**).
2.  Вы можете удалить файл (удалить имя), пока программа в него пишет. Программа продолжит писать в Inode, так как он всё еще существует. Место на диске не освободится, пока программа не закроется.

## Права доступа: Магия тройки

Система прав в Linux элегантна и базируется на восьмеричной системе счисления.
У каждого файла есть три действия:

- **Чтение (r)** = 4 (в бинарном виде 100)
- **Запись (w)** = 2 (в бинарном 010)
- **Исполнение (x)** = 1 (в бинарном 001)

Почему такие числа? Потому что их сумма уникальна. Если права раны `7` (4+2+1), это может быть только полный доступ. Если `5` (4+1), то это Чтение + Исполнение.
Права назначаются трем группам: Владельцу (User), Группе (Group) и Остальным (Others). Комбинация `755` просит систему: "Владельцу дай всё (7), группе дай читать и запускать (5), остальным тоже (5)".

Особняком стоят **Sticky Bit** (защита от удаления чужих файлов в общих папках, как в `/tmp`) и **SUID** (запуск программы с правами владельца файла, обычно root).

## Удаленный доступ: Криптография на службе

Протокол SSH (Secure Shell) де-факто заменил все небезопасные способы управления (Telnet, FTP). Помимо шифрования трафика, он подарил нам удобную аутентификацию по ключам.
Механизм асимметричного шифрования работает как замок и ключ. Вы генерируете пару ключей.
— **Приватный ключ** (ключ) — вы храните под подушкой и никому не показываете.
— **Публичный ключ** (замок) — вы копируете на сервер.

Когда вы стучитесь на сервер, он предлагает вам "открыть" замок. Сделать это может только тот, у кого есть приватный ключ. Пароль передавать по сети не нужно вообще.

---

## Практика

Перейдем к терминалу. Навык нарабатывается только через пальцы.

### 1. Навигация и структура
Попробуем создать структуру проекта.
```bash
# Создаем вложенную структуру одной командой (-p)
mkdir -p project/{src,logs,config}
cd project

# Создаем пустые файлы для тренировки
touch src/main.py config/settings.yaml
```

Попробуйте использовать "расширение скобок" (brace expansion). Это мощная фича bash:
```bash
touch file_{1..5}.txt
# Создаст file_1.txt, file_2.txt ...
```

### 2. Эксперименты с правами
Создадим секретный файл и поиграем с масками.
```bash
echo "Super Secret Password" > secret.data

# Убираем все права для "остальных" и "группы"
chmod 600 secret.data
# Проверяем (ls -l): должно быть -rw-------

# Попробуем прочитать его от имени другого пользователя (если есть) или через sudo
# sudo -u nobody cat secret.data 
# (Получим Permission denied)
```

### 3. Bash-скриптинг: Бэкап
Напишем скрипт, который реально может пригодиться. Он будет архивировать папку и добавлять дату в название.

Создайте файл `backup.sh`:
```bash
#!/bin/bash

# Переменные для удобства
SOURCE_DIR="src"
BACKUP_DIR="backups"
DATE=$(date +%Y-%m-%d_%H-%M-%S)
ARCHIVE_NAME="backup_$DATE.tar.gz"

# Проверка: существует ли папка назначения? Если нет — создаем.
if [ ! -d "$BACKUP_DIR" ]; then
    echo "Creating backup directory..."
    mkdir -p "$BACKUP_DIR"
fi

echo "Starting backup for $SOURCE_DIR..."

# tar -czf: Create, Zip (gzip), File
tar -czf "$BACKUP_DIR/$ARCHIVE_NAME" "$SOURCE_DIR"

echo "Backup created: $BACKUP_DIR/$ARCHIVE_NAME"
```

Сделайте его исполняемым (`chmod +x backup.sh`) и запустите `./backup.sh`.

---

## Ресурсы

— **[Linux Journey](https://linuxjourney.com/)** — Лучший интерактивный учебник для старта.
— **[OverTheWire: Bandit](https://overthewire.org/wargames/bandit/)** — Игра, где вы проходите уровни, взламывая Linux через SSH. Очень рекомендую для практики.
— **[Explainshell](https://explainshell.com/)** — Вставьте любую непонятную команду, и сайт разберет её по флагам.
