# День 2. Git и Systemd

[tools] [devops] [git] [linux]

Вчера мы разбирали, как управлять сервером "в моменте". Но в профессиональной разработке важен процесс во времени. Как вернуть код к состоянию недельной давности? Как гарантировать, что база данных запустится автоматически после перезагрузки сервера в 3 часа ночи?
Ответы на эти вопросы дают **Git** и **Systemd**.

---

## Архитектура Git: Не просто "Сохранить"

Часто Git воспринимают просто как "Ctrl+S на стероидах". Но чтобы понять, почему Git ведет себя так, как он себя ведет (особенно при конфликтах), нужно заглянуть в его внутреннюю механику.

Git — это **Directed Acyclic Graph (DAG)**. Это ориентированный граф без циклов.
В отличие от старых систем (SVN), которые хранили "список изменений" для каждого файла, Git мыслит **снимками (Snapshots)**. В момент коммита Git как бы фотографирует текущее состояние всей вашей папки. Если файл не менялся, он просто делает ссылку на предыдущую "фотографию".

### Криптографическая целостность
В основе всего лежит **SHA-1 хэш**. Каждое изменение, каждый файл, каждая папка и каждый коммит получают уникальный 40-значный идентификатор.
`commit a1b2c3...`
Это дает нам гарантию целостности. Невозможно изменить ни байта в истории (или в файле десятилетней давности), чтобы это не изменило хэш всех последующих коммитов. Это превращает историю проекта в нерушимую цепочку блоков (да, почти как блокчейн).

### Анатомия данных
В папке `.git` скрыт простой, но гениальный механизм:
1.  **Blob (Binary Large Object)** — просто содержимое файла. Без имени. Просто байты.
2.  **Tree (Дерево)** — список, который говорит: "файл `main.py` — это вот этот Blob, а папка `src` — это вот это Tree".
3.  **Commit** — обложка. Она говорит: "Вот корневое Tress проекта, вот автор, вот дата, а вот ссылка на ПРЕДЫДУЩИЙ коммит".

Именно ссылки на родителей и формируют историю. Ветка (branch) в этой системе — это просто стикер с названием "Main", приклеенный на последний коммит. Когда мы делаем новый коммит, мы просто переклеиваем стикер на шаг вперед.

---

## Evolution of Init: Systemd

Когда вы нажимаете кнопку включения сервера, ядро Linux инициализирует оборудование, а затем запускает самый первый процесс с PID 1. Именно этот процесс должен разбудить все остальные программы: сеть, базу данных, веб-сервер.

### От хаоса к порядку
Раньше (в эпоху SysVinit) это делалось набором bash-скриптов, которые запускались строго по очереди. "Сначала сеть... ждем... потом диск... ждем...". Это было медленно и ненадежно. Если скрипт зависал, загрузка останавливалась.

Systemd совершил революцию, перейдя к **декларативному** описанию и **параллельному** запуску.
Systemd не выполняет скрипты линейно. Он строит граф зависимостей (прямо как Git, но для процессов). Вы говорите ему: "Мне нужен Nginx, но он хочет, чтобы СЕТЬ уже была". Systemd сам вычисляет оптимальный порядок запуска, стартуя всё, что можно, параллельно.

### Unit Files
Вместо императивных скриптов ("сделай то, потом сё"), мы пишем конфигурационные файлы (Units). В них мы описываем *желаемое состояние*.
— `Restart=always`: Если процесс упал, подними его.
— `After=network.target`: Не запускай, пока не поднимется сеть.

Этот инструмент превращает Linux из набора разрозненных программ в цельную, самовосстанавливающуюся систему.

---

## Практика

### 1. Git: Работа с ветками и конфликтами
Смоделируем реальную ситуацию разработки.

Создаем репозиторий:
```bash
mkdir git-lab && cd git-lab
git init
echo "print('Version 1.0')" > app.py
git add .
git commit -m "Initial release"
```

Ветвление — это дешевая операция. Создадим ветку для фичи:
```bash
git checkout -b new-feature
echo "print('New cool feature')" >> app.py
git commit -am "Add feature"
```

А теперь вернемся в мастер и сымитируем работу другого коллеги, который тоже трогал этот файл:
```bash
git checkout main
echo "print('Hotfix for bug!')" >> app.py
git commit -am "Critical fix"
```

Теперь у нас две ветки, разошедшиеся от общего предка. Попробуем слить:
```bash
git merge new-feature
```
Git сообщит о **Конфликте**. Это нормально. Откройте файл `app.py`. Вы увидите там маркеры `<<<<<<< HEAD` и `>>>>>>> new-feature`.
Ваша задача — руками отредактировать файл, оставив нужный код, и завершить слияние:
```bash
# После редактирования файла
git add app.py
git commit -m "Merge fix and feature"
```

### 2. Systemd: Пишем свой сервис
Сделаем так, чтобы наш "сервер" запускался сам.

Создайте скрипт `/opt/myserver.sh`:
```bash
#!/bin/bash
while true; do
  echo "Server is running at $(date)" >> /tmp/server.log
  sleep 10
done
```
(`chmod +x /opt/myserver.sh`)

Теперь объясним Systemd, как с этим работать. Создайте файл `/etc/systemd/system/myserver.service`:
```ini
[Unit]
Description=My Test Server
After=network.target

[Service]
# Какой файл исполнять
ExecStart=/opt/myserver.sh
# Что делать, если процесс умер? Перезапускать всегда.
Restart=always
# Задержка перед перезапуском
RestartSec=3
# От чьего имени запускать
User=root

[Install]
# В каком режиме запускать (аналог runlevel 3 — многопользовательский без графики)
WantedBy=multi-user.target
```

Магия управления:
```bash
sudo systemctl daemon-reload      # Перечитываем конфиги
sudo systemctl enable myserver    # Добавляем в автозагрузку
sudo systemctl start myserver     # Запускаем прямо сейчас

# Проверяем
systemctl status myserver
tail -f /tmp/server.log
```

Попробуйте убить процесс вручную через `kill`. Вы увидите в статусе, что Systemd мгновенно перезапустил его.

---

## Ресурсы

— **[Pro Git Book](https://git-scm.com/book/ru/v2)** — Библия Git. Главы 1-3 обязательны к прочтению для понимания внутренней структуры.
— **[Learn Git Branching](https://learngitbranching.js.org/)** — Великолепный визуальный тренажер.
— **[Systemd by Example](https://systemd-by-example.com/)** — Интерактивная песочница для изучения юнитов.
