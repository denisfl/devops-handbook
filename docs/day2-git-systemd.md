# День 2. Git и Systemd

[tools] [devops] [git] [linux]

Вчера мы разбирали, как управлять сервером "в моменте". Но в профессиональной разработке важен процесс во времени. Как вернуть код к состоянию недельной давности? Как гарантировать, что база данных запустится автоматически после перезагрузки сервера в 3 часа ночи?
Ответы на эти вопросы дают **Git** и **Systemd**.

---

## Архитектура Git: Directed Acyclic Graph

Git фундаментально отличается от всех предшественников (SVN, CVS, Perforce). Он не хранит разницу между файлами (diffs). Он хранит **Снимки (Snapshots)**. Представьте, что при каждом коммите Git делает мгновенную фотографию всей вашей файловой системы.

### Как это устроено под капотом?
Git — это **Content-Addressable Filesystem**. Это значит, что имя любого файла в базе данных Git определяется его содержимым.
Когда вы делаете `git add app.py`, Git берет содержимое файла, прогоняет через алгоритм SHA-1 и получает уникальный хэш (например, `a1b2c3...`). Затем он сжимает файл zlib-ом и кладет в папку `.git/objects/a1/b2c3...`. Этот объект называется **Blob**.
**Важно**: Blob хранит *только содержимое*. Он не знает, как файл назывался (`app.py`).

Чтобы запомнить имена и структуру папок, Git создает объект **Tree** (Дерево). Tree — это просто список соответствий: "blob `a1b2c3` лежит под именем `app.py` с правами `644`".
Наконец, объект **Commit** ссылается на это корневое Дерево. Также Коммит хранит метаданные (автор, дата) и, самое главное, ссылку на **Родительский Коммит**.

Именно эта ссылка на родителя превращает историю в **Граф**. Вы не можете изменить старый коммит, потому что изменится его хэш. Если изменится его хэш, то изменится и хэш его потомка (так как потомок содержит хэш родителя внутри себя). Это делает историю Git криптографически защищенной цепочкой (Merkle Tree). 

**Ветка (Branch)** в этой системе технически представляет собой подвижный **указатель (pointer)** на вершину графа (последний коммит). Файл ветки (например, `.git/refs/heads/master`) содержит только 40 байт — хэш последнего коммита. Когда вы создаете новый коммит, Git просто обновляет значение этого указателя. Именно поэтому создание веток в Git происходит мгновенно, независимо от размера проекта.

---

## Evolution of Init: Systemd

Когда вы нажимаете кнопку включения сервера, ядро Linux инициализирует оборудование, а затем запускает самый первый процесс с PID 1. Именно этот процесс должен разбудить все остальные программы: сеть, базу данных, веб-сервер.

### От хаоса к порядку
Раньше (в эпоху SysVinit) это делалось набором bash-скриптов, которые запускались строго по очереди. "Сначала сеть... ждем... потом диск... ждем...". Это было медленно и ненадежно. Если скрипт зависал, загрузка останавливалась.

Systemd совершил революцию, перейдя к **декларативному** описанию и **параллельному** запуску.
Systemd не выполняет скрипты линейно. Он строит граф зависимостей (прямо как Git, но для процессов). Вы говорите ему: "Мне нужен Nginx, но он хочет, чтобы СЕТЬ уже была". Systemd сам вычисляет оптимальный порядок запуска, стартуя всё, что можно, параллельно.

### Unit Files
Вместо императивных скриптов ("сделай то, потом сё"), мы пишем конфигурационные файлы (Units). В них мы описываем *желаемое состояние*.

*   `Restart=always`: Если процесс упал, подними его.
*   `After=network.target`: Не запускай, пока не поднимется сеть.

Этот инструмент превращает Linux из набора разрозненных программ в цельную, самовосстанавливающуюся систему.

---

## Практика

### 1. Git: Работа с ветками и конфликтами
Смоделируем реальную ситуацию разработки.

Создаем репозиторий:
```bash
mkdir git-lab && cd git-lab
git init
echo "print('Version 1.0')" > app.py
git add .
git commit -m "Initial release"
```

Ветвление — это дешевая операция. Создадим ветку для фичи:
```bash
git checkout -b new-feature
echo "print('New cool feature')" >> app.py
git commit -am "Add feature"
```

А теперь вернемся в мастер и сымитируем работу другого коллеги, который тоже трогал этот файл:
```bash
git checkout main
echo "print('Hotfix for bug!')" >> app.py
git commit -am "Critical fix"
```

Теперь у нас две ветки, разошедшиеся от общего предка. Попробуем слить:
```bash
git merge new-feature
```
Git сообщит о **Конфликте**. Это нормально. Откройте файл `app.py`. Вы увидите там маркеры `<<<<<<< HEAD` и `>>>>>>> new-feature`.
Ваша задача — руками отредактировать файл, оставив нужный код, и завершить слияние:
```bash
# После редактирования файла
git add app.py
git commit -m "Merge fix and feature"
```

### 2. Systemd: Пишем свой сервис
Сделаем так, чтобы наш "сервер" запускался сам.

Создайте скрипт `/opt/myserver.sh`:
```bash
#!/bin/bash
while true; do
  echo "Server is running at $(date)" >> /tmp/server.log
  sleep 10
done
```

Сделаем его исполняемым: `chmod +x /opt/myserver.sh`.
Теперь создадим Unit-файл. Это паспорт нашего сервиса:
`/etc/systemd/system/myserver.service`:

```ini
[Unit]
Description=My Simple Logging Server
After=network.target

[Service]
ExecStart=/opt/myserver.sh
Restart=always
User=root

[Install]
WantedBy=multi-user.target
```

Магия Systemd:
```bash
# Перечитываем конфиги
systemctl daemon-reload
# Запускаем
systemctl start myserver
# Включаем автозапуск
systemctl enable myserver
```

Теперь убейте процесс (`kill`), и вы увидите, как Systemd моментально его воскресит. Это и есть Reliability.

---

## Ресурсы

*   **[Pro Git Book](https://git-scm.com/book/en/v2)** — Библия Git. Главы про "Git Internals" обязательны к прочтению для понимания графов.
*   **[Systemd Essentials](https://www.digitalocean.com/community/tutorials/systemd-essentials-working-with-services-units-and-the-journal)** — Хороший гайд от DigitalOcean.
