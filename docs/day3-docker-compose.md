# День 3. Docker и Docker Compose

[tools] [devops] [docker] [containers]

В истории IT было две эры: "до контейнеров" и "после".
В эру "до" мы жили в аду зависимостей. У разработчика на ноутбуке стоит Python 3.9 и всё работает. Он отправляет код админу. Админ заливает его на сервер, где стоит CentOS с Python 3.6. Приложение падает с непонятной ошибкой. Начинаются долгие выяснения "а какая версия библиотеки X у тебя стоит?".
Docker решил эту проблему радикально. Вместо того чтобы пересылать только код, мы начали пересылать **всё окружение целиком**.

---

## Архитектура: Контейнер vs Виртуальная машина

Чтобы понять Docker, нужно перестать путать его с виртуализацией.
Виртуальная машина (например, VMWare или VirtualBox) — это честная эмуляция "железа". Вы ставите туда полноценную ОС, которая запускает свое ядро, драйверы, системные службы. Это надежно, но очень дорого: каждая виртуалка отъедает гигабайты памяти и грузится минуты.

Контейнер — это, по сути, обман зрения. Это обычный процесс в вашей системе, но запущенный в "карцере".
1.  **Namespaces** (Пространства имен): Обманывают процесс, заставляя его думать, что он один в системе. Он видит свой список процессов (PID 1), свою сеть, своих пользователей.
2.  **Cgroups** (Контрольные группы): Ограничивают ресурсы. Мы можем сказать: "этому процессу не больше 512Мб памяти".

Главное отличие: у всех контейнеров **общее Ядро (Kernel)** с хост-системой. Поэтому старт занимает миллисекунды.

### Слоеный пирог (UnionFS)
Образ Docker (Image) — это не просто архив. Это набор слоев, лежащих друг на друге.
Представьте, что вы печете торт.
— Слой 1: Ubuntu (ОС).
— Слой 2: Установка Python (apt-get install).
— Слой 3: Ваш код.

Файловая система объединяет (Union) эти слои в единое целое. Самое важное свойство: все слои образа — **Read Only** (только для чтения).
Когда вы запускаете контейнер, Docker кладет сверху тонкий прозрачный слой для записи. Если вы меняете файл конфигурации, Docker копирует его из нижнего (замороженного) слоя в верхний и меняет копию (**CoW — Copy on Write**).
Это позволяет запускать 100 контейнеров из одного образа, занимая на диске место как для одного.

---

## Оркестрация для бедных: Docker Compose

Запустить один контейнер легко (`docker run`). Но современные приложения — это "зоопарк": веб-сервер, база данных, кэш, очередь задач.
Запускать их руками, прокидывая сети и линки — мучение.

Docker Compose позволяет описать всю архитектуру системы в одном файле `yaml`. Это и есть философия **Infrastructure as Code** в миниатюре. Вместо документации "запусти сначала это, потом то", вы даете команде файл, который сам всё делает.

---

## Практика

### 1. Nginx и статика: Понимаем Volumes
Контейнеры эфемерны. Всё, что записано внутри контейнера, исчезнет вместе с ним (вспоминаем про слой записи). Чтобы данные жили, нам нужно "пробросить" папку внутрь.

Создайте `index.html`:
```html
<h1>Hello from Host!</h1>
```

Запустим Nginx. Обратите внимание на флаг `-v`:
```bash
docker run -d \
  --name web \
  -p 8080:80 \
  -v $(pwd):/usr/share/nginx/html:ro \
  nginx:alpine
```
`:ro` означает Read Only. Контейнер может читать наш файл, но не может его испортить.
Зайдите на `localhost:8080`. Поменяйте файл в редакторе — изменится и сайт.

### 2. Сборка собственного образа
Напишем `Dockerfile` для простого Python-приложения.

`app.py`:
```python
import os
print(f"Hello from {os.environ.get('ENV_NAME', 'Unknown')} environment!")
```

`Dockerfile`:
```dockerfile
# Этап 1: Базовый образ. Alpine весит всего 5Мб.
FROM python:3.9-alpine

# Создаем рабочую директорию
WORKDIR /app

# Копируем код
COPY app.py .

# Команда по умолчанию
CMD ["python", "app.py"]
```

Сборка и запуск:
```bash
docker build -t my-python-app .
docker run -e ENV_NAME="Production" my-python-app
```

### 3. Все вместе: Docker Compose
Поднимем настоящий стек: WordPress + База данных MySQL.

`docker-compose.yml`:
```yaml
version: '3.8'

services:
  db:
    image: mysql:5.7
    # Важно: данные базы должны храниться в Volume, иначе они сотрутся при рестарте
    volumes:
      - db_data:/var/lib/mysql
    environment:
      MYSQL_ROOT_PASSWORD: secret_password
      MYSQL_DATABASE: wordpress

  wordpress:
    image: wordpress:latest
    depends_on:
      - db
    ports:
      - "8000:80"
    environment:
      WORDPRESS_DB_HOST: db:3306 # Compose сам разрезолвит имя сервиса "db" в IP адрес
      WORDPRESS_DB_USER: root
      WORDPRESS_DB_PASSWORD: secret_password

volumes:
  db_data: # Объявляем именованный том
```

Запуск:
```bash
docker-compose up -d
```
Теперь у вас есть полноценный блог на `localhost:8000`. Чтобы всё удалить: `docker-compose down`.

---

## Ресурсы

— **[Docker Curriculum](https://docker-curriculum.com/)** — Отличный туториал для старта.
— **[Best practices for writing Dockerfiles](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)** — Обязательно к прочтению, чтобы не создавать образы по 2 Гигабайта.
— **[Dive](https://github.com/wagoodman/dive)** — Утилита командной строки, которая позволяет "залезть" внутрь слоев образа и посмотреть, где вы потратили лишнее место.
